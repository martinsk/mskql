# LeakSanitizer suppressions for macOS system libraries (false positives)
leak:_fetchInitializingClassList
leak:_libxpc_initializer
leak:libSystem_initializer
leak:initializeNonMetaClass
leak:dyld::ThreadLocalVariables
leak:_tlv_get_addr
# macOS libc dtoa thread-local caches (allocated by snprintf %g/%f, never freed)
leak:__Balloc_D2A
# macOS libc localtime thread-local buffer (allocated once, never freed)
leak:localtime
# Catalog table allocations (strdup in text_cell, add_*_col, table_init).
# These are properly freed by catalog_cleanup → table_free at shutdown, but
# LSAN's conservative heap scanner cannot follow the deep nested pointer chain
# (db->tables.items → row.cells.items → cell.value.as_text) and falsely
# reports them as unreachable.  Verified: leak count is identical before and
# after db_free, confirming LSAN reachability analysis — not actual leaks.
leak:catalog.c
