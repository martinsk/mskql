<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mskql &mdash; Tutorial: Recursive CTEs &amp; Tree Queries</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400;1,500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="tutorial.css">
    <link rel="stylesheet" href="tutorial-interactive.css">
</head>
<body>

<aside class="sidebar">
    <div class="sidebar-title"><a href="../index.html">mskql</a></div>
    <div class="sidebar-subtitle"><a href="index.html">Tutorials</a></div>
    <nav>
        <ul>
            <li><a href="task-tracker.html">1. Task Tracker</a></li>
            <li><a href="reporting-dashboard.html">2. Reporting Dashboard</a></li>
            <li><a href="time-series.html">3. Time-Series Analytics</a></li>
            <li><a href="multi-table-joins.html">4. Multi-Table Joins</a></li>
            <li><a href="schema-evolution.html">5. Schema Evolution</a></li>
            <li><a href="recursive-ctes.html" class="active">6. Recursive CTEs</a></li>
            <li><a href="set-operations.html">7. Set Operations</a></li>
            <li><a href="string-math-functions.html">8. String &amp; Math</a></li>
            <li><a href="indexes-performance.html">9. Indexes</a></li>
            <li><a href="sequences-enums.html">10. Sequences &amp; Enums</a></li>
        </ul>
        <div class="nav-label">Reference</div>
        <ul>
            <li><a href="../grammar.html">SQL Grammar</a></li>
            <li><a href="../bench-vs-pg.html">Benchmarks</a></li>
        </ul>
    </nav>
</aside>

<h1>Recursive CTEs &amp; Tree Queries</h1>
<span class="subtitle">Hierarchical data, depth tracking, and path building</span>
<p class="byline">Tutorial 6 of 11</p>
<hr class="title-rule">

<p>
    Many real-world datasets are hierarchical: org charts, category trees,
    bill-of-materials. A <code>WITH RECURSIVE</code> CTE lets you walk these
    trees in pure SQL&mdash;no application-level loops, no stored procedures.
    This tutorial builds an employee org chart and queries it 7 different ways.
</p>

<!-- ─── Schema ──────────────────────────────────────────────── -->

<h2>1. Schema and seed data</h2>

<p>
    One table with a self-referencing foreign key: each employee points to
    their manager. The CEO has <code>manager_id = NULL</code>.
</p>

<pre><code class="language-sql">CREATE TABLE employees (
    id          SERIAL PRIMARY KEY,
    name        TEXT NOT NULL,
    title       TEXT NOT NULL,
    manager_id  INT REFERENCES employees(id),
    salary      INT NOT NULL
);

INSERT INTO employees (name, title, manager_id, salary) VALUES
    ('Alice',   'CEO',              NULL, 200000),
    ('Bob',     'VP Engineering',   1,    160000),
    ('Charlie', 'VP Sales',         1,    155000),
    ('Diana',   'Tech Lead',        2,    130000),
    ('Eve',     'Senior Engineer',  2,    120000),
    ('Frank',   'Sales Manager',    3,    110000),
    ('Grace',   'Engineer',         4,    100000),
    ('Hank',    'Engineer',         4,     95000),
    ('Ivy',     'Sales Rep',        6,     80000),
    ('Jack',    'Sales Rep',        6,     75000);</code></pre>

<p>
    10 employees across 4 levels. Alice manages Bob and Charlie directly;
    Bob manages Diana and Eve; Diana manages Grace and Hank; and so on.
</p>

<!-- ─── Basic recursive CTE ────────────────────────────────── -->

<h2>2. Walk the full org chart</h2>

<p>
    A recursive CTE has two parts: the <strong>anchor</strong> (the starting
    rows) and the <strong>recursive term</strong> (the join that walks one
    level deeper). Here we start from the CEO and walk down.
</p>

<div class="query-pair">
<pre><code class="language-sql">WITH RECURSIVE org AS (
    SELECT id, name, title,
           manager_id, 0 AS depth
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.id, e.name, e.title,
           e.manager_id, o.depth + 1
    FROM employees e
    JOIN org o ON e.manager_id = o.id
)
SELECT name, title, depth
FROM org
ORDER BY depth, name;</code></pre>
<div class="result-wrap">
<p class="result-label">Result</p>
<table class="result-table">
<thead><tr><th>name</th><th>title</th><th>depth</th></tr></thead>
<tbody>
<tr><td>Alice</td><td>CEO</td><td class="num-val">0</td></tr>
<tr><td>Bob</td><td>VP Engineering</td><td class="num-val">1</td></tr>
<tr><td>Charlie</td><td>VP Sales</td><td class="num-val">1</td></tr>
<tr><td>Diana</td><td>Tech Lead</td><td class="num-val">2</td></tr>
<tr><td>Eve</td><td>Senior Engineer</td><td class="num-val">2</td></tr>
<tr><td>Frank</td><td>Sales Manager</td><td class="num-val">2</td></tr>
<tr><td>Grace</td><td>Engineer</td><td class="num-val">3</td></tr>
<tr><td>Hank</td><td>Engineer</td><td class="num-val">3</td></tr>
<tr><td>Ivy</td><td>Sales Rep</td><td class="num-val">3</td></tr>
<tr><td>Jack</td><td>Sales Rep</td><td class="num-val">3</td></tr>
</tbody>
</table>
</div>
</div>

<p>
    The <code>depth</code> column starts at 0 for the CEO and increments by 1
    at each level. The recursion terminates naturally when no more children
    are found.
</p>

<!-- ─── Subtree ────────────────────────────────────────────── -->

<h2>3. Subtree under a specific manager</h2>

<p>
    Change the anchor to start from Bob instead of the CEO. This gives you
    only the engineering subtree&mdash;4 employees instead of 10.
</p>

<div class="query-pair">
<pre><code class="language-sql">WITH RECURSIVE team AS (
    SELECT id, name, title, 0 AS depth
    FROM employees
    WHERE name = 'Bob'

    UNION ALL

    SELECT e.id, e.name, e.title,
           t.depth + 1
    FROM employees e
    JOIN team t ON e.manager_id = t.id
)
SELECT name, title, depth
FROM team
ORDER BY depth, name;</code></pre>
<div class="result-wrap">
<p class="result-label">Result</p>
<table class="result-table">
<thead><tr><th>name</th><th>title</th><th>depth</th></tr></thead>
<tbody>
<tr><td>Bob</td><td>VP Engineering</td><td class="num-val">0</td></tr>
<tr><td>Diana</td><td>Tech Lead</td><td class="num-val">1</td></tr>
<tr><td>Eve</td><td>Senior Engineer</td><td class="num-val">1</td></tr>
<tr><td>Grace</td><td>Engineer</td><td class="num-val">2</td></tr>
<tr><td>Hank</td><td>Engineer</td><td class="num-val">2</td></tr>
</tbody>
</table>
</div>
</div>

<!-- ─── Walk upward ────────────────────────────────────────── -->

<h2>4. Walk upward to the root</h2>

<p>
    Reverse the direction: start from a leaf node and walk <em>up</em> to the
    CEO. This answers &ldquo;who is Grace&rsquo;s management chain?&rdquo;
</p>

<div class="query-pair">
<pre><code class="language-sql">WITH RECURSIVE chain AS (
    SELECT id, name, title,
           manager_id, 0 AS depth
    FROM employees
    WHERE name = 'Grace'

    UNION ALL

    SELECT e.id, e.name, e.title,
           e.manager_id, c.depth + 1
    FROM employees e
    JOIN chain c
      ON e.id = c.manager_id
)
SELECT name, title, depth
FROM chain
ORDER BY depth;</code></pre>
<div class="result-wrap">
<p class="result-label">Result</p>
<table class="result-table">
<thead><tr><th>name</th><th>title</th><th>depth</th></tr></thead>
<tbody>
<tr><td>Grace</td><td>Engineer</td><td class="num-val">0</td></tr>
<tr><td>Diana</td><td>Tech Lead</td><td class="num-val">1</td></tr>
<tr><td>Bob</td><td>VP Engineering</td><td class="num-val">2</td></tr>
<tr><td>Alice</td><td>CEO</td><td class="num-val">3</td></tr>
</tbody>
</table>
</div>
</div>

<p>
    The join is flipped: <code>e.id = c.manager_id</code> walks from child to
    parent instead of parent to child.
</p>

<!-- ─── Aggregate subtree ──────────────────────────────────── -->

<h2>5. Aggregate over a subtree</h2>

<p>
    Combine the recursive CTE with an aggregate to compute the total salary
    cost of each manager&rsquo;s entire subtree (including themselves).
</p>

<div class="query-pair">
<pre><code class="language-sql">WITH RECURSIVE team AS (
    SELECT id, name, id AS root_id
    FROM employees
    WHERE id IN (1, 2, 3)

    UNION ALL

    SELECT e.id, e.name, t.root_id
    FROM employees e
    JOIN team t ON e.manager_id = t.id
)
SELECT m.name AS manager,
       COUNT(*) AS team_size,
       SUM(e.salary) AS total_cost
FROM team t
JOIN employees e ON t.id = e.id
JOIN employees m ON t.root_id = m.id
GROUP BY m.name
ORDER BY total_cost DESC;</code></pre>
<div class="result-wrap">
<p class="result-label">Result</p>
<table class="result-table">
<thead><tr><th>manager</th><th>team_size</th><th>total_cost</th></tr></thead>
<tbody>
<tr><td>Alice</td><td class="num-val">10</td><td class="num-val">1125000</td></tr>
<tr><td>Bob</td><td class="num-val">5</td><td class="num-val">605000</td></tr>
<tr><td>Charlie</td><td class="num-val">4</td><td class="num-val">420000</td></tr>
</tbody>
</table>
</div>
</div>

<p>
    Alice&rsquo;s subtree is the entire company: 10 people, $1,125,000 total.
    Bob&rsquo;s engineering org is 5 people at $605,000. Charlie&rsquo;s sales
    team is 4 people at $420,000.
</p>

<!-- ─── Depth limit ────────────────────────────────────────── -->

<h2>6. Limit recursion depth</h2>

<p>
    Add a <code>WHERE</code> clause on the recursive term to stop after 2
    levels. This is useful for large trees where you only need nearby nodes.
</p>

<div class="query-pair">
<pre><code class="language-sql">WITH RECURSIVE org AS (
    SELECT id, name, title, 0 AS depth
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.id, e.name, e.title,
           o.depth + 1
    FROM employees e
    JOIN org o ON e.manager_id = o.id
    WHERE o.depth < 2
)
SELECT name, title, depth
FROM org
ORDER BY depth, name;</code></pre>
<div class="result-wrap">
<p class="result-label">Result</p>
<table class="result-table">
<thead><tr><th>name</th><th>title</th><th>depth</th></tr></thead>
<tbody>
<tr><td>Alice</td><td>CEO</td><td class="num-val">0</td></tr>
<tr><td>Bob</td><td>VP Engineering</td><td class="num-val">1</td></tr>
<tr><td>Charlie</td><td>VP Sales</td><td class="num-val">1</td></tr>
<tr><td>Diana</td><td>Tech Lead</td><td class="num-val">2</td></tr>
<tr><td>Eve</td><td>Senior Engineer</td><td class="num-val">2</td></tr>
<tr><td>Frank</td><td>Sales Manager</td><td class="num-val">2</td></tr>
</tbody>
</table>
</div>
</div>

<p>
    Only 6 rows instead of 10&mdash;the level-3 employees (Grace, Hank, Ivy,
    Jack) are excluded by the <code>WHERE o.depth &lt; 2</code> guard.
</p>

<!-- ─── Non-recursive CTE ──────────────────────────────────── -->

<h2>7. Non-recursive CTEs for readability</h2>

<p>
    Not every CTE needs <code>RECURSIVE</code>. A plain CTE is just a named
    subquery&mdash;useful for breaking complex queries into readable steps.
</p>

<div class="query-pair">
<pre><code class="language-sql">WITH dept_salary AS (
    SELECT manager_id,
           COUNT(*) AS reports,
           AVG(salary) AS avg_salary
    FROM employees
    WHERE manager_id IS NOT NULL
    GROUP BY manager_id
)
SELECT e.name, e.title,
       d.reports,
       d.avg_salary
FROM employees e
JOIN dept_salary d
  ON e.id = d.manager_id
ORDER BY d.reports DESC;</code></pre>
<div class="result-wrap">
<p class="result-label">Result</p>
<table class="result-table">
<thead><tr><th>name</th><th>title</th><th>reports</th><th>avg_salary</th></tr></thead>
<tbody>
<tr><td>Alice</td><td>CEO</td><td class="num-val">2</td><td class="num-val">157500</td></tr>
<tr><td>Bob</td><td>VP Engineering</td><td class="num-val">2</td><td class="num-val">125000</td></tr>
<tr><td>Diana</td><td>Tech Lead</td><td class="num-val">2</td><td class="num-val">97500</td></tr>
<tr><td>Frank</td><td>Sales Manager</td><td class="num-val">2</td><td class="num-val">77500</td></tr>
<tr><td>Charlie</td><td>VP Sales</td><td class="num-val">1</td><td class="num-val">110000</td></tr>
</tbody>
</table>
</div>
</div>

<!-- ─── Wrap-up ─────────────────────────────────────────────── -->

<h2>What you learned</h2>

<p>
    In this tutorial you modeled a 10-person org chart and queried it with
    recursive and non-recursive CTEs:
</p>

<ul>
    <li><strong><code>WITH RECURSIVE</code></strong> to walk a self-referencing tree top-down</li>
    <li><strong>Anchor + recursive term</strong> pattern with <code>UNION ALL</code></li>
    <li><strong>Depth tracking</strong> via an incrementing counter column</li>
    <li><strong>Subtree queries</strong> by changing the anchor&rsquo;s <code>WHERE</code> clause</li>
    <li><strong>Upward traversal</strong> by flipping the join direction</li>
    <li><strong>Aggregation over subtrees</strong> by carrying a <code>root_id</code> through the recursion</li>
    <li><strong>Depth limiting</strong> with a <code>WHERE</code> guard on the recursive term</li>
    <li><strong>Plain CTEs</strong> for readable multi-step queries without recursion</li>
</ul>

<div class="tutorial-nav">
    <a class="prev" href="schema-evolution.html">Schema Evolution</a>
    <a class="next" href="set-operations.html">Set Operations</a>
</div>

<footer class="site-footer">
    <a href="https://www.linkedin.com/in/martinskristiansen">Martin S. Kristiansen</a>
    &ensp;&middot;&ensp;
    <a href="https://github.com/martinsk/mskql">Source on GitHub</a>
    &ensp;&middot;&ensp;
    <a href="../index.html">Documentation</a>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
<script>hljs.highlightAll();</script>
<script src="../wasm/mskql-wasm.js"></script>
<script src="tutorial-interactive.js"></script>
</body>
</html>
