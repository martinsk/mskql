<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mskql &mdash; SQL Reference</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400;1,500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>

<p class="breadcrumb"><a href="index.html">&larr; mskql</a></p>

<h1>SQL Reference</h1>
<span class="subtitle">Supported SQL and data types</span>
<hr class="title-rule">

<p>
    Every SQL statement, clause, and data type supported by mskql.
    For the formal grammar, see the <a href="grammar.html">Grammar Reference</a>.
</p>

<h2 id="supported-sql">Supported SQL</h2>

<table>
    <thead>
        <tr><th>Category</th><th>Supported</th><th>Notes</th></tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>DDL</strong></td>
            <td><code>CREATE TABLE</code> (<code>IF NOT EXISTS</code>),
                <code>DROP TABLE</code>,
                <code>CREATE INDEX</code> (<code>IF NOT EXISTS</code>),
                <code>DROP INDEX</code>,
                <code>CREATE TYPE &hellip; AS ENUM</code>, <code>DROP TYPE</code>,
                <code>CREATE SEQUENCE</code>, <code>DROP SEQUENCE</code>,
                <code>CREATE VIEW</code>, <code>DROP VIEW</code>,
                <code>ALTER TABLE</code> (<code>ADD</code>/<code>DROP</code>/<code>RENAME COLUMN</code>,
                <code>ALTER COLUMN TYPE</code>)</td>
            <td>Schema changes are immediate; no background rewrite. Views are expanded at query time.</td>
        </tr>
        <tr>
            <td><strong>DML</strong></td>
            <td><code>INSERT</code> (single, multi-row, <code>INSERT&hellip;SELECT</code>),
                <code>SELECT</code>, <code>UPDATE</code> (incl. <code>UPDATE&hellip;FROM</code>),
                <code>DELETE</code>,
                <code>RETURNING</code>,
                <code>ON CONFLICT DO NOTHING</code>,
                <code>ON CONFLICT DO UPDATE</code>,
                <code>TRUNCATE TABLE</code>,
                <code>COPY TO STDOUT</code> (tab/CSV/header),
                <code>COPY FROM STDIN</code> (tab/CSV)</td>
            <td>In-place updates&mdash;no MVCC tuple versioning. Inserts are 3&times; faster than PostgreSQL.</td>
        </tr>
        <tr>
            <td><strong>Filtering</strong></td>
            <td><code>WHERE</code> with <code>AND</code>/<code>OR</code>/<code>NOT</code>,
                <code>BETWEEN</code>, <code>IN</code> (values, subqueries, multi-column),
                <code>ANY</code>/<code>ALL</code>,
                <code>LIKE</code>, <code>ILIKE</code>,
                <code>IS [NOT] NULL</code>, <code>IS [NOT] DISTINCT FROM</code>,
                <code>=</code> <code>!=</code> <code>&lt;&gt;</code>
                <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td>
            <td>Compound filters (AND/OR trees) run in the plan executor on columnar blocks.</td>
        </tr>
        <tr>
            <td><strong>Joins</strong></td>
            <td><code>INNER</code>, <code>LEFT</code>, <code>RIGHT</code>,
                <code>FULL OUTER</code>, <code>CROSS</code>,
                <code>NATURAL</code>, <code>USING</code>,
                <code>LATERAL</code>, multi-table,
                compound <code>ON</code> conditions (<code>AND</code>/<code>OR</code>)</td>
            <td>Hash join for equi-joins; nested loop for CROSS/LATERAL. Join cache reuses hash tables across queries.</td>
        </tr>
        <tr>
            <td><strong>Aggregation</strong></td>
            <td><code>COUNT</code>, <code>SUM</code>, <code>AVG</code>,
                <code>MIN</code>, <code>MAX</code>,
                <code>COUNT(DISTINCT&nbsp;col)</code>,
                <code>STRING_AGG()</code>, <code>ARRAY_AGG()</code>,
                expression aggregates (<code>SUM(price&nbsp;*&nbsp;qty)</code>),
                <code>GROUP BY</code> (multi-column, positional: <code>GROUP&nbsp;BY&nbsp;1,&nbsp;2</code>),
                <code>GROUP BY ROLLUP</code>, <code>GROUP BY CUBE</code>,
                <code>HAVING</code></td>
            <td>Columnar hash aggregation&mdash;6&ndash;10&times; faster than PostgreSQL on typical workloads.</td>
        </tr>
        <tr>
            <td><strong>Window functions</strong></td>
            <td><code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code>,
                <code>NTILE()</code>, <code>PERCENT_RANK()</code>, <code>CUME_DIST()</code>,
                <code>LAG()</code>, <code>LEAD()</code>,
                <code>FIRST_VALUE()</code>, <code>LAST_VALUE()</code>, <code>NTH_VALUE()</code>,
                <code>SUM()</code>, <code>COUNT()</code>, <code>AVG()</code>
                over <code>PARTITION BY &hellip; ORDER BY &hellip;</code>,
                window frames (<code>ROWS BETWEEN &hellip;</code>)</td>
            <td>Sort-based window execution with bump-allocated accumulators. ~2&times; faster than PostgreSQL.</td>
        </tr>
        <tr>
            <td><strong>Set operations</strong></td>
            <td><code>UNION</code>, <code>UNION ALL</code>,
                <code>INTERSECT</code>, <code>EXCEPT</code></td>
            <td><code>UNION</code> deduplicates via hash; <code>UNION ALL</code> concatenates without dedup.</td>
        </tr>
        <tr>
            <td><strong>CTEs</strong></td>
            <td><code>WITH name AS (SELECT &hellip;) SELECT &hellip;</code>,
                <code>WITH RECURSIVE</code></td>
            <td>Simple CTEs are inlined when possible, avoiding temp-table materialization overhead.</td>
        </tr>
        <tr>
            <td><strong>Expressions</strong></td>
            <td><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code>,
                unary <code>-</code>, operator precedence,
                <code>CASE WHEN&hellip;THEN&hellip;ELSE&hellip;END</code>,
                <code>COALESCE()</code>, <code>NULLIF()</code>,
                <code>GREATEST()</code>, <code>LEAST()</code></td>
            <td>Evaluated in columnar batches via <code>PLAN_EXPR_PROJECT</code>&mdash;35% faster than PostgreSQL.</td>
        </tr>
        <tr>
            <td><strong>Result control</strong></td>
            <td><code>DISTINCT</code>, <code>DISTINCT ON</code>,
                <code>ORDER BY</code> (multi-column, per-column <code>ASC</code>/<code>DESC</code>),
                <code>LIMIT</code>, <code>OFFSET</code></td>
            <td><code>LIMIT</code> short-circuits the plan&mdash;stops pulling blocks once satisfied.</td>
        </tr>
        <tr>
            <td><strong>Constraints</strong></td>
            <td><code>NOT NULL</code>, <code>UNIQUE</code>, <code>PRIMARY KEY</code>,
                <code>DEFAULT</code>, <code>CHECK</code>,
                <code>REFERENCES</code> (foreign keys with
                <code>ON DELETE/UPDATE CASCADE</code>,
                <code>RESTRICT</code>, <code>SET NULL</code>,
                <code>SET DEFAULT</code>)</td>
            <td>Enforced at write time. Foreign keys support all four referential actions.</td>
        </tr>
        <tr>
            <td><strong>Transactions</strong></td>
            <td><code>BEGIN</code>, <code>COMMIT</code>, <code>ROLLBACK</code>
                (snapshot-based)</td>
            <td>Lazy copy-on-write snapshots. First write to a table triggers O(N) deep copy.</td>
        </tr>
        <tr>
            <td><strong>String functions</strong></td>
            <td><code>UPPER()</code>, <code>LOWER()</code>, <code>LENGTH()</code>,
                <code>TRIM()</code>, <code>CONCAT()</code>, <code>CONCAT_WS()</code>,
                <code>||</code>, <code>SUBSTRING()</code>,
                <code>REPLACE()</code>, <code>LPAD()</code>/<code>RPAD()</code>,
                <code>POSITION()</code>, <code>SPLIT_PART()</code>,
                <code>LEFT()</code>/<code>RIGHT()</code>,
                <code>REPEAT()</code>, <code>REVERSE()</code>, <code>INITCAP()</code></td>
            <td>16 string functions. All run in the expression projector for batched evaluation.</td>
        </tr>
        <tr>
            <td><strong>Math functions</strong></td>
            <td><code>ABS()</code>, <code>CEIL()</code>/<code>CEILING()</code>,
                <code>FLOOR()</code>, <code>ROUND()</code> (with optional decimal places),
                <code>POWER()</code>, <code>SQRT()</code>, <code>MOD()</code>,
                <code>SIGN()</code>, <code>RANDOM()</code></td>
            <td>9 math functions. <code>ROUND(expr, n)</code> supports arbitrary decimal places.</td>
        </tr>
        <tr>
            <td><strong>Date/time functions</strong></td>
            <td><code>NOW()</code>, <code>CURRENT_TIMESTAMP</code>, <code>CURRENT_DATE</code>,
                <code>EXTRACT()</code>, <code>DATE_TRUNC()</code>, <code>DATE_PART()</code>,
                <code>AGE()</code>, <code>TO_CHAR()</code>,
                date/timestamp &plusmn; interval arithmetic,
                timestamp &minus; timestamp &rarr; interval,
                date &plusmn; integer days</td>
            <td>Full interval arithmetic. <code>TO_CHAR</code> supports common PostgreSQL format patterns.</td>
        </tr>
        <tr>
            <td><strong>Type casting</strong></td>
            <td><code>CAST(expr AS type)</code>, <code>expr::type</code> postfix syntax,
                numeric&harr;numeric, numeric&harr;text, text&harr;boolean,
                text&rarr;date/timestamp conversions</td>
            <td>Both <code>CAST()</code> and <code>::</code> syntax. Implicit coercion for compatible types.</td>
        </tr>
        <tr>
            <td><strong>Table functions</strong></td>
            <td><code>generate_series(start, stop [, step])</code> &mdash; integer,
                timestamp, and date sequences with optional step and column aliases</td>
            <td>Supports integer, date, and timestamp series. Max 10M rows safety limit.</td>
        </tr>
        <tr>
            <td><strong>Sequences &amp; utilities</strong></td>
            <td><code>NEXTVAL()</code>, <code>CURRVAL()</code>,
                <code>GEN_RANDOM_UUID()</code></td>
            <td><code>SERIAL</code> columns use sequences internally. UUIDs are v4 random.</td>
        </tr>
        <tr>
            <td><strong>Foreign tables</strong></td>
            <td><code>CREATE FOREIGN TABLE name (col type, &hellip;) OPTIONS (filename &rsquo;path.parquet&rsquo;)</code>
                &mdash; maps a Parquet file to a SQL table. Query with standard SQL:
                joins, aggregates, subqueries, CTEs. Result cache applies.
                <code>DROP FOREIGN TABLE</code></td>
            <td>Parquet files queried on demand. Cached queries are 2&ndash;14&times; faster than DuckDB.</td>
        </tr>
        <tr>
            <td><strong>Subqueries</strong></td>
            <td>Scalar subqueries in <code>SELECT</code> list,
                correlated subqueries,
                <code>EXISTS</code> / <code>NOT EXISTS</code> (correlated),
                <code>IN (SELECT&hellip;)</code></td>
            <td><code>IN</code> subqueries use hash semi-join (O(N+M)). Correlated subqueries: 145&times; faster than PG.</td>
        </tr>
        <tr>
            <td><strong>Introspection</strong></td>
            <td><code>EXPLAIN</code> (plan-based and legacy execution paths),
                <code>SHOW</code> (<code>server_version</code>, <code>search_path</code>,
                <code>client_encoding</code>, etc.),
                <code>SET</code>/<code>RESET</code>/<code>DISCARD</code> (accepted, no-op),
                <code>information_schema.tables</code>,
                <code>information_schema.columns</code>,
                <code>pg_catalog.pg_type</code>,
                <code>pg_catalog.pg_class</code>,
                <code>pg_catalog.pg_namespace</code>,
                <code>pg_catalog.pg_attribute</code></td>
            <td><code>EXPLAIN</code> shows the plan tree. System catalogs enable tool compatibility (e.g. DBeaver, pgAdmin).</td>
        </tr>
    </tbody>
</table>

<p>
    &#8594;&ensp;<a href="grammar.html"><strong>Full SQL grammar reference</strong></a> &mdash; production
    rules for every statement, with implemented/not-implemented status for each feature.
</p>

<h2 id="data-types">Data Types</h2>

<table>
    <thead>
        <tr><th>Type</th><th>Storage</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td><code>SMALLINT</code> / <code>INT2</code></td><td>2 bytes</td><td>16-bit signed integer (&minus;32,768 to 32,767)</td></tr>
        <tr><td><code>INT</code></td><td>4 bytes</td><td>32-bit signed integer. Default for most integer columns.</td></tr>
        <tr><td><code>BIGINT</code></td><td>8 bytes</td><td>64-bit signed integer. Use for row counts or large IDs.</td></tr>
        <tr><td><code>FLOAT</code></td><td>8 bytes</td><td>Double-precision (C <code>double</code>). Use for scientific or approximate values.</td></tr>
        <tr><td><code>NUMERIC</code> / <code>DECIMAL</code></td><td>8 bytes</td><td>Stored as <code>double</code>. Use for monetary or exact decimal values.</td></tr>
        <tr><td><code>TEXT</code></td><td>variable</td><td>Variable-length string. No length limit.</td></tr>
        <tr><td><code>VARCHAR(n)</code></td><td>variable</td><td>String with max length <em>n</em>. Stored as TEXT internally.</td></tr>
        <tr><td><code>BOOLEAN</code></td><td>1 byte</td><td><code>TRUE</code> / <code>FALSE</code>. Accepts <code>t</code>/<code>f</code>, <code>yes</code>/<code>no</code>, <code>1</code>/<code>0</code>.</td></tr>
        <tr><td><code>DATE</code></td><td>variable</td><td>Calendar date (YYYY-MM-DD).</td></tr>
        <tr><td><code>TIME</code></td><td>variable</td><td>Time of day (HH:MM:SS).</td></tr>
        <tr><td><code>TIMESTAMP</code></td><td>variable</td><td>Date and time (YYYY-MM-DD HH:MM:SS). Supports arithmetic with intervals.</td></tr>
        <tr><td><code>TIMESTAMPTZ</code></td><td>variable</td><td>Timestamp with time zone awareness.</td></tr>
        <tr><td><code>INTERVAL</code></td><td>variable</td><td>Time span. Supports <code>'1 year 2 months 3 days'</code> syntax.</td></tr>
        <tr><td><code>UUID</code></td><td>variable</td><td>128-bit identifier. Generated with <code>GEN_RANDOM_UUID()</code>.</td></tr>
        <tr><td><code>SMALLSERIAL</code> / <code>SERIAL</code> / <code>BIGSERIAL</code></td><td>2/4/8 bytes</td><td>Auto-incrementing integer backed by a sequence.</td></tr>
        <tr><td><code>ENUM</code></td><td>4 bytes</td><td>User-defined type with ordinal storage. Compared by declaration order.</td></tr>
    </tbody>
</table>

<footer class="site-footer">
    <a href="https://www.linkedin.com/in/martinskristiansen">Martin S. Kristiansen</a>
    &ensp;&middot;&ensp;
    <a href="https://github.com/martinsk/mskql">Source on GitHub</a>
    &ensp;&middot;&ensp;
    <a href="index.html">Documentation</a>
</footer>

</body>
</html>
